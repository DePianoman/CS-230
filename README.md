# CS-230

* Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?
  The Gaming Room wanted to make a cloud-based system that can serve multiple operating systems so that anyone can play their game on their web-based application of choice.
* What did you do particularly well in developing this documentation?
  I'm not entirely sure as I still don't think I understand what I was meant to be doing. I tried doing what I thought was right but I'm not sure I was doing that.
* What about the process of working through a design document did you find helpful when developing the code?
  Honestly I didn't find much helpful as I can already tell what exactly I can and can't do when looking at a prompt, as I've been doing this for almost 10 years now, and have recently picked up GitHub as a place to put my works so I can collaborate with people and let them review my code and tell me what I can improve, as well as for basic version control.
* If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?
  Probably all of it, as again I don't think I understood what I was meant to be doing. I tried to state what exactly can and can't be done, or what can be done but what would be better.
* How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?
  It's very important to meet the user's needs as it would be impossible for them to deploy a product that they physically cannot deploy. The user's needs should be top priority for this purpose and this purpose alone.
* How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?
  Honestly when I approach designing software, I think of multiple ways I could approach it that I know wouldn't break constraints, do a quick map of what could go where, think in the future about if it's maintainable, and then implement it. I've been doing this for years and that's how I plan to continue to do it as my friends in the field do it almost that exact same way.
